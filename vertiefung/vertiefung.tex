\documentclass[abstracton,12pt]{scrartcl}
    
\usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{pdfpages}
\usepackage{forest}
\usepackage{multicol}
\usepackage{varwidth}
\usepackage{verbatim}
\usepackage{cleveref}
\usepackage{minted}
\usepackage{framed}
\usepackage[ruled,vlined]{algorithm2e}
\usepackage{caption}
\usepackage{subcaption}
\usepackage{soul}
% \usepackage{geometry}
% \usepackage{titlesec}

\forestset{qtree/.style={for tree={parent anchor=south, child anchor=north,align=left,inner sep=0pt}}}
\graphicspath{ {images/} }

% \setlength{\multicolsep}{6.0pt plus 2.0pt minus 1.5pt}% 50% of original values
% \titleformat{\chapter}{}{\thechapter}{}{}
% \titlespacing{\chapter}{-100pt}{-100pt}{-100pt}

% --------- 

\titlehead{Department of Informatics, University of Zürich}
\subject{\vspace*{2cm}BSc Vertiefungsarbeit}
\title{Detecting Volatile Index Nodes in Apache Jackrabbit Oak}
\author{
    Rafael Kallis\\[-5pt]
    \scriptsize Matrikelnummer: 14-708-887\\[-5pt]
    \scriptsize Email: \texttt{rk@rafaelkallis.com}
}
\date{\vspace*{2cm}October 3, 2017}
\publishers{
    \small supervised by Prof.\ Dr.\ Michael\ Böhlen and Kevin\ Wellenzohn \\[5cm]
    \begin{tikzpicture}[overlay]
    \node at (-3,-3) {\includegraphics[height=1.5cm]{IFIlogo}};
    \node at (7,-3) {\includegraphics[height=1.5cm]{dbtgBW}};
    \end{tikzpicture}
}

% \dedication{dedicated to xxx}

% --------- 

\theoremstyle{definition}

\newtheorem{definition}{Definition}
% \newtheorem{figure}{Figure}
\newtheorem{example}{Example}
% \newtheorem{theorem}{Theorem}
% \newtheorem{lemma}{Lemma}

\crefname{algocfline}{algorithm}{algorithms}
\Crefname{algocfline}{Algorithm}{Algorithms}

\crefname{figure}{Fig.}{Figs.}
\Crefname{figure}{Figure}{Figures}

\crefname{example}{Ex.}{Ex.}
\Crefname{example}{Example}{Examples}

% \newenvironment{proof}
%     {\noindent{\bf Proof:\rm}}{\hfill$\Box$\vspace{\medskipamount}}

\newenvironment{centerverbatim}{\par\centering\varwidth{\linewidth}\verbatim}
    {\endverbatim\endvarwidth\par}

\def\bbbr{{\rm I\!R}}
\def\bbbm{{\rm I\!M}}
\def\bbbn{{\rm I\!N}}
\def\bbbz{{\rm I\!Z}}

% --------- 

\begin{document}

\maketitle

% \chapter*{Acknowledgements}

% \begin{abstract}
%   ...
% \end{abstract}

% \chapter*{Zusammenfassung}

% \tableofcontents
% \listoffigures
% \listoftables

\newpage
\section{Introduction}

Frequently adding and removing data from hierarchical indexes causes them to repeatedly grow and shrink.
A single insertion or deletion can trigger a sequence of structural index modifications (node insertions/deletions) in a hierarchical index.
Skewed and update-heavy workloads trigger repeated structural index updates over a small subset of nodes to the index.

Informally, a frequently added or removed node is called \textit{volatile}.
Volatile nodes deteriorate index update performance due to two reasons.
First, frequent structural index modifications are expensive since they cause many disk accesses.
Second, frequent structural index modifications also increase the likelihood of conflicting index updates by concurrent transactions.
Conflicting index updates further deteriorate update performance since concurrency control protocols need to resolve the conflict.

Wellenzohn et al.~\cite{KW17} propose the Workload-Aware Property Index (WAPI). 
The WAPI exploits the workloads' skewness by identifying and not removing volatile nodes from the index, 
thus significantly reducing the number of expensive structural index modifications.
Since fewer nodes are inserted/deleted, the likelihood of conflicting index updates by concurrent transactions is reduced.

The goal of this project is to implement a WAPI, as proposed by \cite{KW17} in Apache Jackrabbit Oak (Oak) in order to improve the transactional throughput of Oak.
In \Cref{sec:wapi} we describe how nodes are inserted, queried and deleted from the WAPI.
Next, we describe how volatility is computed in \Cref{sec:volatility}.
Finally, a reference implementation in Java is presented in \Cref{sec:implementation}.

\subsection{Apache Jackrabbit Oak (Oak)}

% Oak\footnote{https://jackrabbit.apache.org/oak/} is a hierarchical distributed database system which makes use of a hierarchical index. 
Oak is a hierarchical distributed database system which makes use of a hierarchical index. 
Multiple transactions can work concurrently by making use of Multiversion Concurrency Control (MVCC)~\cite{GW02}, a commonly used optimistic concurrency control technique~\cite{TM11}.

\Cref{fig:architecture} depicts Oak's multi-tier architecture.
Oak embodies the \textit{Database Tier}.
% Whilst Oak is responsible for handling the database logic, it stores the actual data on MongoDB\footnote{https://www.mongodb.com/what-is-mongodb}, labeled as \textit{Persistence Tier}.
Whilst Oak is responsible for handling the database logic, it stores the actual data on MongoDB, labeled as \textit{Persistence Tier}.
On the other end, applications can make use of Oak as shown in \Cref{fig:architecture} under \textit{Application Tier}.
% One such application is Adobe's enterprise content management system (CMS), the Adobe Experience Manager\footnote{http://www.adobe.com/marketing-cloud/experience-manager.html}.
One such application is Adobe's enterprise content management system (CMS), the Adobe Experience Manager.

\begin{figure}[h]
    \begin{center}
        \begin{tikzpicture}[scale=0.7,thick]
            \node (mongo) at (0, 0) {\includegraphics[width = 0.7cm]{MONGO}};
            \node (oak_a) at (-2, 2) {\includegraphics[width = 0.7cm]{OAK}};
            \node (oak_b) at (0, 2) {\includegraphics[width = 0.7cm]{OAK}};
            \node (oak_c) at (2, 2) {\includegraphics[width = 0.7cm]{OAK}};
            \node (app_a) at (-2, 4) {\includegraphics[width = 0.7cm]{AEM}};
            \node (app_b) at (0, 4) {\includegraphics[width = 0.7cm]{AEM}};
            \node (app_c) at (2, 4) {\includegraphics[width = 0.7cm]{AEM}};
            \node (mongo_desc) at (5, 0) {\footnotesize \textit{Persistence Tier}};
            \node (oak_desc) at (5, 2) {\footnotesize \textit{Database Tier}};
            \node (mongo_desc) at (5, 4) {\footnotesize \textit{Application Tier}};
            \foreach \from/\to in {app_a/oak_a, app_b/oak_b, app_c/oak_c, oak_a/mongo, oak_b/mongo, oak_c/mongo}
            \draw [->] (\from) -- (\to);
        \end{tikzpicture}
    \end{center}
    \vspace{-0.5cm}
    \caption{Apache Jackrabbit Oak's system architecture.}
    \label{fig:architecture}
\end{figure}

\newpage

\section{Workload Aware Property Index (WAPI)}
\label{sec:wapi}

The WAPI is a hierarchical index and indexes the properties of nodes.
It takes into account if an index node is volatile before performing structural index modifications.
If a node is considered volatile, we do not remove it from the index.
In the following section, we will see how to add, query and remove nodes from the index.

\subsection{Insertion}

The WAPI is hierarchically organized under \texttt{/index} node.
The second index level consists of all properties $k$ we want to index.
The third index level contains any values $v$ of property $k$.
The remaining index levels replicate all nodes from the root node to any content node with $k$ set to $v$.
Some node $m$ is added to the WAPI iff $m$ has a property $k$ set to $v$, as shown in \Cref{algo:add_triple_wapi}.
Starting from \texttt{/index}, we descend down to \texttt{/index/k}, followed by \texttt{/index/k/v}.
Next, we descend down from \texttt{/index/k/v} along the index nodes on the absolute path from the root to node $m$.
While we descend the WAPI, we create any node $n$ that does not exist and assign it to variable $tail$.
At the end of the tree traversal, $tail$ corresponds to index node \texttt{/index/k/v/m}. 
$tail$'s property $k$ is finally set to $v$.

\begin{example}
    Consider \Cref{fig:add_wapi}.
    Given snapshot $G^i$, transaction $T_j$ adds the property-value pair $x=1$ to \texttt{/a/b} and commits snapshot $G^j$.
    Starting from \texttt{/index} and descending down to \texttt{/index/x/1/a/b}, we create each node on the way since they do not exist yet.
    Finally, we set property $x=1$ on \texttt{/index/x/1/a/b}.
\end{example}

\vspace{1.3cm}

\begin{figure}[h]
    \vspace{-5mm}
        \begin{multicols}{2}
            \noindent
            \begin{large}$$ G^i \xrightarrow{\quad T_j \quad} G^j $$\end{large}
            \begin{scriptsize}
                \begin{multicols}{2}
                    \noindent
                    \begin{center}
                        \framebox(100,130){
                            \begin{forest} qtree,
                                [
                                    [$\lambda:\texttt{index}$]
                                    [,phantom]
                                    [$\lambda:a$,name=a
                                        [,phantom]
                                        [$\lambda:b$,name=b]
                                        [,phantom]
                                        [$\lambda:c$]
                                    ]
                                ]
                            \end{forest}
        
                            \vspace{27mm}
                        }
        
                        Snapshot $G^i$
                    \end{center}
                    \columnbreak
                    \begin{center}
                        \framebox(100,130){
                            \begin{forest} qtree,
                                [
                                    [$\lambda:\texttt{index}$
                                        [$\lambda:\texttt{x}$
                                            [$\lambda:\texttt{1}$
                                                [$\lambda:a$
                                                [$\lambda:b$ \\ $\texttt{x}:1$]
                                                ]
                                            ]
                                        ]
                                    ]
                                    [,phantom]
                                    [$\lambda:a$,name=a
                                        [,phantom]
                                        [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$,name=b]
                                        [,phantom]
                                        [$\lambda:c$]
                                    ]
                                ]
                            \end{forest}
                        }
        
                        Snapshot $G^j$
                    \end{center}    
                \end{multicols}
            \end{scriptsize}
            \columnbreak
            ~

            \vspace{7.8mm}
            \begin{algorithm}[H]
                \label{algo:add_triple_wapi}
                \caption{AddTripleWAPI}
                \DontPrintSemicolon
                \begin{footnotesize}
                    \KwData{Triple $(k, v, m)$, where $k$ is a property, $v$ a value and $m$ a content node.}
                    \vspace{2.6mm}
                    $tail \longleftarrow \texttt{/index}$\;
                    \For{$n \in \langle \texttt{/i/k},~\texttt{/i/k/v},\dots,\texttt{/i/k/v/m}\rangle$}{
                        \If{$n$ does not exist}{
                            create node $n$\;
                        }
                        $tail \longleftarrow n$\;
                    }
                    $tail[k] \longleftarrow v$
                \end{footnotesize}
            \end{algorithm}
        \end{multicols}
    \vspace{-8mm}
    \caption{
        Adding a node in WAPI. \texttt{/i} is an abbreviation for \texttt{/index}.
        Property $\lambda$ denotes the label of a node.
    }
    \label{fig:add_wapi}
\end{figure}

\newpage

\subsection{Querying}

Oak mostly executes content-and-structure (CAS) queries~\cite{CM15}, defined as follows.

\begin{definition}
    (CAS-Query): Given node $m$, property $k$ and value $v$, a CAS query $Q(k,v,m)$ returns all descendants of $m$ which have $k$ set to $v$, i.e 
    $$ Q(k,v,m) = \{~n~|~n[k] = v \land n \in desc(m)~\}$$
\end{definition}

\Cref{algo:query_wapi} describes how we answer a CAS query using the WAPI.
Given property $k$, value $v$ and node $m$, we start descending down to node \texttt{/index/k/v/m}.
Next, we iterate through all its descendants $n$.
We return a set consisting of \textit{content} nodes $*n$ corresponding to every \textit{index} node $n$ with property $k$ set to $v$.
The path of content node $*n$ is obtained by removing the first three nodes on the path of index node $n$.
For example, if $n = \texttt{/index/x/1/a/b}$ is an index node, the corresponding content node is $*n = \texttt{/a/b}$.
If \texttt{/index/k/v/m} does not exist, then $desc(\texttt{/index/k/v/m}) = \emptyset$.

\begin{example}
    Consider $Q(x, 1, \texttt{/a})$, which queries for every descendant of \texttt{/a} with \texttt{x} set to $1$.
    Assuming we execute the query on the tree depicted in \Cref{fig:cas_query}, 
    WAPI descends to node \texttt{/index/x/1/a} and traverses all descendants.
    Its only descendant is $n = \texttt{/index/x/1/a/b}$ and since $n[x] = 1$ the content node $*n = \texttt{/a/b}$ is returned.
    That is, $Q(x, 1, \texttt{/a}) = \{~\texttt{/a/b}~\}$
\end{example}

\vspace{2.5cm}

\begin{figure}[h]
    \begin{multicols}{2}
        \begin{center}
            \begin{footnotesize}
                \framebox{
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                        [$\lambda:b$ \\ $\texttt{x}:1$]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$,name=b]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}
                }
            \end{footnotesize}
        \end{center}    
        \columnbreak
        \begin{algorithm}[H]
            \DontPrintSemicolon
            \begin{scriptsize}
                \label{algo:query_wapi}
                \caption{QueryWAPI}
                \KwData{Query $Q(k, v, m)$, where $k$ is a property, $v$ a value and $m$ a node.}
                \KwResult{A set of nodes satisfying $Q(k,v,m)$}
                $r \longleftarrow \emptyset$\;
                \For{$n \in desc(\texttt{/index/k/v/m})$}{
                    \If{$n[k] = v$}{
                        $r \longleftarrow r \cup \{ *n \}$\;
                    }
                }
                \Return{r}\;
            \end{scriptsize}
        \end{algorithm}
        \begin{scriptsize}
            Where $desc(\texttt{/index/k/v/m})$ is the set of descendants of node \texttt{/index/k/v/m}, $n[k]$ is property $k$ of node $n$ and $*n$ is the content node corresponding to $n$.
        \end{scriptsize}
    \end{multicols}
    \caption{CAS Query example.}
    \label{fig:cas_query}
\end{figure}

\newpage

\subsection{Deletion}

If a property-value pair is deleted from a content node, the corresponding index entry is deleted from WAPI.
During deletion, we intend to remove a node from the WAPI.
Volatile nodes influence the logic of the deletion process.
A workload aware property index detects which nodes are volatile and does not remove them.
The process of classifying a node as volatile, will be explained in more details in \Cref{sec:volatility}.
For the moment we assume that a function $isVolatile(n)$ is given that classifies $n$ either as volatile or as non-volatile.

\Cref{algo:remove_triple_wapi} describes the process of removing node $n = \texttt{/index/k/v/m}$ from WAPI after property $k$ was changed or removed from content node $m$.
We first descend down to node $n = \texttt{/index/k/v/m}$, which we intend to remove.
We remove property $k$ from $n$ by setting $k$'s value to \textsc{NIL}.
If $n$ is (a) a leaf node, and (b) does not have property $k$ set to $v$ and (c) is not volatile, we remove it.
If $n$ was removed, we repeat the process on its parent node $par(n)$.
The process repeats on all ancestors and ends if we propagate up to \texttt{/index} or reach a node that violates at least one of the above three conditions.

\begin{example}
    \Cref{fig:remove_wapi} depicts the following scenario.
    Assume \texttt{/index/x/1/a/b} (colored red) is volatile in all three snapshots $G^i, G^j, G^k$.
    Given snapshot $G^i$, transaction $T_j$ removes property $x=1$ from \texttt{/a/b} and commits snapshot $G^j$.
    Since \texttt{/index/x/1/a/b} is volatile, it was not removed from the WAPI, only its property $x=1$ is removed.
    Given snapshot $G^j$, transaction $T_k$ removes property \texttt{x} from \texttt{/a/c} and commits snapshot $G^k$.
    Since \texttt{/index/x/1/a/c} was not volatile, was a leaf-node, and property $x=1$ was just removed, the index node was removed from the WAPI.
    Since its parent node has another child node, the parent is not removed and the deletion process stops.
\end{example}

\begin{figure}[h]
    \begin{large}
        $$ G^i \xrightarrow{\quad T_j \quad} G^j \xrightarrow{\quad T_k \quad} G^k $$
    \end{large}
    \begin{scriptsize}
        \begin{multicols}{3}
            \begin{center}
                \framebox(130,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                            [$\lambda:b$ \\ $\texttt{x}:1$, red]
                                            [,phantom]
                                            [,phantom]
                                            [$\lambda:c$ \\ $\texttt{x}:1$]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [,phantom]
                            [,phantom]
                            [$\lambda:a$
                                [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$]
                                [,phantom]
                                [$\lambda:c$ \\ $\texttt{x}:\texttt{1}$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^i$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(130,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                            [$\lambda:b$, red]
                                            [,phantom]
                                            [,phantom]
                                            [$\lambda:c$ \\ $\texttt{x}:1$]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [,phantom]
                            [,phantom]
                            [$\lambda:a$
                                [$\lambda:b$]
                                [,phantom]
                                [$\lambda:c$ \\ $\texttt{x}:\texttt{1}$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^j$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(130,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                            [$\lambda:b$, red]
                                                [,phantom]
                                                [,phantom]
                                                [,phantom]
                                                [,phantom]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [,phantom]
                            [,phantom]
                            [$\lambda:a$
                                [$\lambda:b$]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^k$
            \end{center}
        \end{multicols}
    \end{scriptsize}
    \caption{Removing a node from the WAPI. Assume \texttt{/index/x/1/a/b} (colored red) is volatile in all three snapshots $G^i, G^j, G^k$.}
    \label{fig:remove_wapi}
\end{figure}

\begin{algorithm}[H]
    \label{algo:remove_triple_wapi}
    \caption{RemoveTripleWAPI}
    \DontPrintSemicolon
    \begin{footnotesize}
        \KwData{Triple $(k, v, m)$, where $k$ is a property, $v$ a value and $m$ a node.}
        $n \longleftarrow \texttt{/index/k/v/m}$\;
        $n[k] \longleftarrow \textsc{nil}$\;
        \While{$n \neq \texttt{/index} \land chd(n) = \emptyset \land n[k] \neq v \land \lnot \ isVolatile(n)$}{
            $u \longleftarrow n$\;
            $n \longleftarrow par(n)$\;
            remove node $u$\;
        }
    \end{footnotesize}
\end{algorithm}
\begin{scriptsize}
    Where $chd(n)$ is the set of children of node $n$ and $par(n)$ is the parent of $n$.
\end{scriptsize}

\section{Volatility}
\label{sec:volatility}

Volatility is the measure which is used by the WAPI in order to distinguish when to remove a node or not from the index.

Wellenzohn et al.~\cite{KW17} propose to look at the recent transactional
workload to check whether a node $n$ is volatile. The workload on Oak instance
$O_i$ is represented by a sequence $H_i = \langle \ldots, G^a, G^b, G^c
\rangle$ of snapshots, called a history. Let $t_n$ be the current time and $t(G^b)$
be the point in time snapshot $G^b$ was committed, $N(G^a)$ is the set of
nodes which are members of snapshot $G^a$.  $pre(G^b)$ is the predecessor of
snapshot $G^b$ in $H_i$.

Node $n$ is volatile iff $n$'s volatility count is at least $\tau$, called volatility threshold.
The volatility count of $n$ is defined as the number of times $n$ was added or removed from snapshots in a sliding window of length $L$ over history $H_i$.
Let $n^i$ denote version $i$ of node $n$ that belongs to the node set $N(G^i)$ of snapshot $G^i$.
Given two snapshots $G^a$ and $G^b$ we write $n^a$ and $n^b$ to emphasize that nodes $n^a$ and $n^b$ are two versions of the same node $n$, i.e, they have the same absolute path from the root node.

\begin{definition}
    (Volatility Count): The volatility count $vol(n)$ of node $n$ is the number of times node $n$ was added or removed from snapshots contained in a sliding window with length $L$ over history $H_i$.
    \begin{equation}
        \begin{split}
            vol(n) = | \{ G^b | G^b \in H_i \land t(G^b) \in [t_{n-L+1}, t_n] \land \exists G^a[ \\
            \qquad G^a = pre(G^b) \land ([n^a \notin N(G^a) \land n^b \in N(G^b)]\lor \\
            \qquad [n^a \in N(G^a) \land n^b \notin N(G^b)] )]\} |
        \end{split}
    \end{equation}
    \label{def:vol_count}
\end{definition}

\begin{definition}
    (Volatile Node): Node $n$ is volatile iff $n$'s volatility count (see \Cref{def:vol_count}) is greater or equal than the volatility threshold $\tau$, i.e 
    $$ isVolatile(n) \iff vol(n) \geq \tau $$
\end{definition}

\begin{example}
    Consider the snapshots depicted in \Cref{fig:vol_example}.
    Assume $H_h = \langle G^i,G^j,G^k,G^l \rangle$.
    $O_h$ executes transactions $T_j, T_k, T_l$. Snapshot $G^i$ was committed at time $t(G^i) = t$.
    Given snapshot $G^i$, transaction $T_j$ removes property $x$ from \texttt{/a/b} and commits snapshot $G^j$ at time $t(G^j) = t + 1$.
    Next, transaction $T_k$ adds the property $x=1$ to \texttt{/a/b} given snapshot $G^j$ and commits snapshot $G^k$ at time $t(G^k) = t + 2$.
    Finally transaction $T_l$ removes property \texttt{x} from \texttt{/a/b} given $G^k$ and commits $G^l$ at time $t(G^l) = t + 3$.

    If $\tau = 2$ (volatility threshold), $L = 4$ (sliding window length) and $n = \texttt{\footnotesize /index/x/1/a/b}$, then:
    \begin{itemize}
        \item at time $t_n = t$ \quad \ \ we have that: \quad $vol(n) = 0 \implies isVolatile(n) = \bot$
        \item at time $t_n = t + 1 $ we have that: \quad $ vol(n) = 1  \implies isVolatile(n) = \bot$
        \item at time $t_n = t + 2 $ we have that: \quad $ vol(n) = 2  \implies isVolatile(n) = \top$
        \item at time $t_n = t + 3 $ we have that: \quad $ vol(n) = 2  \implies isVolatile(n) = \top$
    \end{itemize}
    
    Since index node $n$ is not volatile at $t_n = t$, transaction $T_j$ removes it from the index.
    But at $t_n = t + 2$, $n$ is volatile (colored red) and transaction $T_l$ does not remove it, instead it only removes property $x=1$ from $n$.
\end{example}

\vspace{2cm}

\begin{figure}[h]
    \begin{large}
        $$ G^i \xrightarrow{\quad T_j \quad} G^j \xrightarrow{\quad T_k \quad} G^k \xrightarrow{\quad T_l \quad} G^l$$
    \end{large}
    \begin{scriptsize}
        \begin{multicols}{4}
            \begin{center}
                \framebox(100,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                        [$\lambda:b$ \\ $\texttt{x}:1$]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$,name=b]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^i$

                $t(G^i) = t$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(100,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$,name=b]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}

                    \vspace{27mm}
                }

                Snapshot $G^j$

                $t(G^j) = t + 1$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(100,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                        [$\lambda:b$ \\ $\texttt{x}:1$, red]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^k$

                $t(G^k) = t + 2$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(100,130){
                    \
                    
                    \vspace{-24mm}
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                            [$\lambda:b$, red]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$,name=b]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}

                    \vspace{27mm}
                }

                Snapshot $G^l$

                $t(G^l) = t + 3$
            \end{center}
        \end{multicols}
    \end{scriptsize}
    \caption{Node \texttt{/index/x/1/a/b} becomes volatile after a deletion by $T_j$ and insertion by $T_k$. Therefore the node cannot be deleted by transaction $T_l$.}
    \label{fig:vol_example}
\end{figure}

\newpage
\section{Implementation}
\label{sec:implementation}

\subsection{Checking Node Volatility}

In order to classify a node $n$ as volatile, we have to compute $n$'s volatility count using the corresponding JSON document on MongoDB.
The document contains all \textit{revisions} (i.e, versions) of $n$ throughout history $H_i$ of an Oak instance $O_i$.
\Cref{fig:json_simple} depicts such a document.
We omit non relevant properties.
Property \texttt{"\_deleted"} contains key value pairs which encode when the node was added or removed from snapshots.
A key is a revision that is composed of three parts connected by a dash (-): (1) a timestamp, (2) a counter that is used to differentiate between value changes at the same instance of time, and (3) the identifier $i$ of the Oak instance $O_i$ committing the change.
A value is a boolean variable which is \texttt{true} ($\top$) iff $n$ was added at the point of time indicated by the revision key, and \texttt{false} ($\bot$) otherwise.
\begin{example}
    Consider revision (\texttt{r15cac0dbb00-0-2}, \texttt{false}) in \Cref{fig:json_simple}.
    Character \texttt{r} is a standard prefix and can be neglected.
    The \texttt{15cac0dbb00} following \texttt{r}, is a timestamp (number of milliseconds since the Epoch) in hexadecimal encoding which represents the time at which the change was committed, Thursday June 15 2017 2:00:00 PM in this example.
    The \texttt{0} following the timestamp, is a counter which is used for tie-breaking between transactions committed at the same instance of time.
    Since all revisions in this example are committed at different time points, all counters are $0$.
    The \texttt{2} following the counter, tells that the change was committed by Oak instance $O_2$ with an ID of \texttt{2}.
    Value \texttt{false} indicates \texttt{/index/x/1/a/b} was added at that point of time.
\end{example}

\begin{figure}[h]
    \begin{scriptsize}
        \begin{centerverbatim}{   
    "_id": "5:/index/x/1/a/b", 
    "_deleted": {             
        "r15cac0dbb00-0-2": false,
        "r15cabff1500-0-2": true,
        "r15ca9f191c0-0-1": false,
        /* ... */
    },
    /* ... */
}\end{centerverbatim}
    \end{scriptsize}
    \caption{JSON document of an index node.}
    \label{fig:json_simple}
\end{figure}

Having seen what a node document looks like, we can now describe how we classify a node as volatile.
\Cref{fig:is_volatile} shows the native Java-implementation of $isVolatile(n)$ in Oak.
$isVolatile(n)$ is given a node's corresponding JSON document.
We iterate through the revisions of property \texttt{"\_deleted"} in most-recent first fashion.
Notice that the \texttt{keySet} referred to in the Java code is based on Java's ordered sets and is maintained in descending order according to the revision.
If a revision is outside the sliding window we stop iterating because remaining revisions cannot be more recent.
We increment the volatility count for every visible revision.
A revision is visible if it is contained in the Oak instance's history.
If the volatility count reaches at least $\tau$ we break the loop.
When exiting the loop, we finally check if the volatility count is at least $\tau$ and return the result.
The Java-implementation of the helper functions \texttt{isVisible} and \texttt{isInSlidingWindow} is provided in the Appendix.

\begin{figure}
    \begin{framed}
        \begin{scriptsize}
            \begin{minted}{java}
/**
    * Determines if node is volatile.
    * @param nodeDocument: document of node.
    * @returns true iff node is volatile.
    */            
    boolean isVolatile(NodeDocument nodeDocument) {

    int vol = 0;
    
    for (Revision r : nodeDocument.getLocalDeleted().keySet()) {
        if (!isInSlidingWindow(r)){
            break;
        }
        if (!isVisible(r)){
            continue;
        }
        if (vol++ >= getVolatilityThreshold()) {
            break;
        }
    }
    return vol >= getVolatilityThreshold();
}
\end{minted}
        \end{scriptsize}
    \end{framed}
    \caption{Java implementation for detecting volatile index nodes.}
    \label{fig:is_volatile}
\end{figure}

\subsection{Document Splitting}

Jackrabbit Oak periodically checks a node's corresponding document for its size and if necessary splits it up and moves old data to a new split document.
Performance suffers if looking at split documents is required while computing the volatility count, since MongoDB has to be accessed in order to lookup the split document.
We modify Oak's document splitting implementation as mentioned in~\cite{KW17} in order to prevent split document lookups.
Essentially, all necessary information is kept in a document to compute the volatility count.
A race condition could occur if multiple Oak instances split the same document at the same time.
In order to avoid such a race condition, each Oak instance only moves changes committed by itself.

\Cref{fig:split_document} depicts the Java implementation of the document splitting process.
We iterate through the revisions of the \texttt{"\_deleted"} property of the given document in most-recent first fashion.
A revision gets moved to the split document iff: (1) it is not the most recent revision committed by the local Oak instance, (2) it is not among the $\tau$ first visible revisions contained in the sliding window, and (3) the revision was committed by the local Oak instance.

\begin{example}
    \label{ex:split_doc}
    Consider \Cref{fig:split_doc_mongo}.
    We see how a node's corresponding document is split on Oak instance $O_1$, assuming $\tau = 3$, $t_{\texttt{last\_sync}} = $ {\footnotesize 2017.06.15 13:59}, $L = 24$ hours, $t_n = $ {\footnotesize 2017.06.15 14:01}.
    \Cref{fig:split_doc_debug} shows a table with intermediate values during computation.
    ``$t(r)$'' is the point in time revision $r$ was committed. Only the day, hours and minutes are shown for brevity.
    ``$c(r)$'' is the ID of the cluster node that committed revision $r$.
    ``Vis.'' is true iff the revision is visible to the local cluster node.
    ``$\in$Win.'' is true iff the revision is in the sliding window.
    ``Vol.'' represents the volatility count at that step of the iteration. 
    ``Split'' is true iff the revision is moved to the split document.

    We will briefly walk through the iterations during the document split depicted in \Cref{fig:split_doc_mongo}.
    $r^1$ does not increment the volatility count, since it is not visible to the local Oak instance because $t_{\texttt{last\_sync}} < t(r^1)$.
    Thus $r^1$ is not moved to the split document.
    The three next revisions, $r^2,r^3,r^4$, increment the volatility count because they are in the sliding window but are not moved to the split document because $vol < \tau$.
    $r^5$ is still in the sliding window and therefore increment the volatility count.
    Since there are already $\tau$ revisions in the document, we move $r^5$ to the split document.
    Finally, any following revisions committed by the local Oak instance (i.e, $r^7, r^8, r^9$) are moved to the split document since there are already $\tau$ revisions in the document, enough to decide the node's volatility.
\end{example}

\begin{figure}
    \begin{framed}
        \begin{scriptsize}
            \begin{minted}{java}
/**
* Splits the "_deleted" property on the given document.
* @param NodeDocument the node document.
*/
void splitDeleted(NodeDocument nodeDocument) {

    int vol = 0;
    boolean first = true;

    for (Revision r : nodeDocument.getLocalDeleted().keySet()) {
        if (first && r.getClusterId() == getClusterId()) {
            first = false;
            if (isInSlidingWindow(r)) {
                ++vol;
            }
            continue;
        }
        if (isInSlidingWindow(r) && isVisible(r) && vol++ < getVolatilityThreshold()) {
            continue;
        }
        if (r.getClusterId() != getClusterId()) {
            continue;
        }
        moveToSplitDocument(r);

    }
}
            \end{minted}
        \end{scriptsize}
    \end{framed}
    \caption{Java implementation for splitting the node document.}
    \label{fig:split_document}
\end{figure}

\begin{figure}
    \begin{subfigure}[b]{0.5\textwidth}
        \begin{scriptsize}
            \begin{centerverbatim}
{   
    "_id": "5:/index/x/1/a/b", 
    "_deleted": {                 /* DD HH:MM */
    "r15cac0dbb00-0-2": false,  /* 15 14:00 */
    "r15cabff1500-0-2": true,   /* 15 13:44 */
    "r15ca9f191c0-0-1": false,  /* 15 04:10 */
    "r15ca76fc8e0-0-1": true,   /* 14 16:29 */
    "r15ca73b9980-0-1": false,  /* 14 15:32 */
    "r15ca5e9c520-0-2": true,   /* 14 09:23 */
    "r15ca5a8c480-0-1": false,  /* 14 08:12 */
    "r15ca5a6efc0-0-1": true,   /* 14 08:10 */
    "r15ca58e37a0-0-1": false   /* 14 07:43 */
    },
    /* ... */
}
            \end{centerverbatim}
        \end{scriptsize}
        \caption{Before splitting.}
    \end{subfigure}
    \begin{subfigure}[b]{0.5\textwidth}
        \begin{scriptsize}
            \begin{centerverbatim}
{   
    "_id": "5:/index/x/1/a/b", 
    "_deleted": {                 /* DD HH:MM */
    "r15cac0dbb00-0-2": false,  /* 15 14:00 */
    "r15cabff1500-0-2": true,   /* 15 13:44 */
    "r15ca9f191c0-0-1": false,  /* 15 04:10 */
    "r15ca76fc8e0-0-1": true,   /* 14 16:29 */
    "r15ca5e9c520-0-2": true    /* 14 09:23 */
    },
    /* ... */
},
{   
    "_id": "6:p/index/x/1/a/b/r15ca58e37a0-0-1", 
    "_deleted": {                 /* DD HH:MM */
    "r15ca73b9980-0-1": false,  /* 14 15:32 */
    "r15ca5a8c480-0-1": false,  /* 14 08:12 */
    "r15ca5a6efc0-0-1": true,   /* 14 08:10 */
    "r15ca58e37a0-0-1": false   /* 14 07:43 */
    },
    /* ... */
}
            \end{centerverbatim}
        \end{scriptsize}
        \caption{After splitting.}
    \end{subfigure}
    \caption{Document splitting. We use the same parameters as in \Cref{ex:split_doc}.}
    \label{fig:split_doc_mongo}
\end{figure}

\begin{figure}
    \begin{center}
        \begin{footnotesize}
            \begin{tabular}{|c|c|c|c|c|c|c|} 
                \hline
                $r$     & $t(r)$ &    $c(r)$ &        Vis. &      $\in$Win. &         Vol. &      Split \\
                \hline
                $r^1$ & 15 14:00 &  2 &             $\bot$ &         $\top$ &                 0 &                 $\bot$ \\ 
                \hline
                $r^2$ & 15 13:44 &  2 &             $\top$ &         $\top$ &                 1 &                 $\bot$ \\
                \hline
                $r^3$ & 15 04:10 &  1 &             $\top$ &         $\top$ &                 2 &                 $\bot$ \\
                \hline
                $r^4$ & 14 16:29 &  1 &             $\top$ &         $\top$ &                 3 &                 $\bot$ \\
                \hline
                $r^5$ & 14 15:32 &  1 &             $\top$ &         $\top$ &                 4 &                 $\top$ \\
                \hline
                $r^6$ & 14 09:23 &  2 &             $\top$ &         $\bot$ &                 4 &                 $\bot$ \\
                \hline
                $r^7$ & 14 08:12 &  1 &             $\top$ &         $\bot$ &                 4 &                 $\top$ \\
                \hline
                $r^8$ & 14 08:10 &  1 &             $\top$ &         $\bot$ &                 4 &                 $\top$ \\
                \hline
                $r^9$ & 14 07:43 &  1 &             $\top$ &         $\bot$ &                 4 &                 $\top$ \\
                \hline
            \end{tabular}
        \end{footnotesize}
    \end{center}
    \caption{
        Intermediate values of computation while splitting document \texttt{/index/x/1/a/b} as shown in \Cref{fig:split_doc_mongo}.
        We use the same parameters as in \Cref{ex:split_doc}.
    }
    \label{fig:split_doc_debug}
\end{figure}

\newpage

\bibliographystyle{abbrv}
\bibliography{vertiefung}

\newpage

\section{Appendix}

\subsection{Helper Functions}

\Cref{fig:helper^functions} presents the Java implementation of two helper functions.
$isVisible(r)$ determines if revision $r$ is visible to the local Oak instance $O_i$.
$isInSlidingWindow(r)$ determines if revision $r$ is in the siliding window.

\begin{figure}[h]
    \begin{framed}
        \begin{scriptsize}
            \begin{minted}{java}
/**
    * Checks if r is visible to the local cluster node
    * @param r the revision
    * @returns true iff r is visible to the local cluster node
    */
boolean isVisible(Revision r) {
    return r.getClusterId() == getClusterId()
            || (r.compareRevisionTime(documentNodeStore
                    .getHeadRevision()
                    .getRevision(getClusterId())) < 0);
}

/**
    * Checks if r is in the sliding window
    * @param r the revision
    * @returns true iff r is in the sliding window
    */
boolean isInSlidingWindow(Revision r){
    return System.currentTimeMillis() - getSlidingWindowLength() < r.getTimestamp();
}
            \end{minted}
        \end{scriptsize}
    \end{framed}
    \caption{Java implementation for helper functions.}
    \label{fig:helper^functions}
\end{figure}

\end{document}
