\documentclass[abstracton,12pt]{scrreprt}

\usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{pdfpages}
\usepackage{forest}
\usepackage{multicol}
\usepackage{varwidth}
\usepackage{verbatim}
\usepackage{cleveref}
\usepackage{minted}
\usepackage{framed}
\usepackage[ruled,vlined]{algorithm2e}
% \usepackage{geometry}
% \usepackage{titlesec}

\forestset{qtree/.style={for tree={parent anchor=south, child anchor=north,align=left,inner sep=0pt}}}
\graphicspath{ {images/} }

% \setlength{\multicolsep}{6.0pt plus 2.0pt minus 1.5pt}% 50% of original values
% \titleformat{\chapter}{}{\thechapter}{}{}
% \titlespacing{\chapter}{-100pt}{-100pt}{-100pt}

% --------- 

\titlehead{Department of Informatics, University of Zürich}
\subject{\vspace*{2cm}BSc Vertiefungsarbeit}
\title{Detecting Volatile Index Nodes in a Hierarchical Database System}
\author{
  Rafael Kallis\\[-5pt]
  \scriptsize Matrikelnummer: 14-708-887\\[-5pt]
  \scriptsize Email: \texttt{rk@rafaelkallis.com}
}
\date{\vspace*{2cm}October 3, 2017}
\publishers{
  \small supervised by Prof.\ Dr.\ Michael\ Böhlen and Kevin\ Wellenzohn \\[5cm]
  \begin{tikzpicture}[overlay]
    \node at (-3,-3) {\includegraphics[height=1.5cm]{IFIlogo}};
    \node at (7,-3) {\includegraphics[height=1.5cm]{dbtgBW}};
  \end{tikzpicture}
}

% \dedication{dedicated to xxx}

% --------- 

\newtheorem{definition}{Definition}
% \newtheorem{figure}{Figure}
\newtheorem{example}{Example}
% \newtheorem{theorem}{Theorem}
% \newtheorem{lemma}{Lemma}

\crefname{algocfline}{algorithm}{algorithms}
\Crefname{algocfline}{Algorithm}{Algorithms}

\crefname{figure}{Fig.}{Figs.}
\Crefname{figure}{Figure}{Figures}

\crefname{example}{Ex.}{Ex.}
\Crefname{example}{Example}{Examples}

% \newenvironment{proof}
%     {\noindent{\bf Proof:\rm}}{\hfill$\Box$\vspace{\medskipamount}}

\newenvironment{centerverbatim}{\par\centering\varwidth{\linewidth}\verbatim}
    {\endverbatim\endvarwidth\par}

\def\bbbr{{\rm I\!R}}
\def\bbbm{{\rm I\!M}}
\def\bbbn{{\rm I\!N}}
\def\bbbz{{\rm I\!Z}}

% --------- 

\begin{document}

\maketitle

% \chapter*{Acknowledgements}

% \begin{abstract}
%   ...
% \end{abstract}

% \chapter*{Zusammenfassung}

% \tableofcontents
% \listoffigures
% \listoftables

\chapter{Introduction}

Adding and removing data from hierarchical indexes causes them to grow and shrink.
They grow and shrink, since adding or removing nodes cause a sequence of nodes to be added or removed in addition.
Skewed and update-heavy workloads trigger repeated structural index updates over a small subset of nodes to the index.
Informally, a frequently added or removed node is called \textit{volatile}.
Volatile nodes deteriorate index update performance due to the frequent structural index modifications.
Frequent structural index modifications also increase the likelihood of conflicting index updates by concurrent transactions.
Conflicting index updates further deteriorate update performance since they cause the transactions to synchronize in order to resolve the conflict.

% Hierarchical indexes with skewed and update-heavy workloads grow and shrink often,
% since adding and removing nodes cause a sequence of nodes to be added or removed in addition, thus deteriorating the index update performance.
% Index update performance also suffers from conflicting index updates.
% Highly skewed workloads create hotspots where nodes are frequently added or removed, increasing conflicting index updates, as shown in (ref kevin paper).
% A frequently added or removed node is a volatile node.



Wellenzohn et al.~\cite{KW17} propose a workload aware property index (WAPI). 
The WAPI exploits the workloads' skewness by not removing volatile nodes from the index, 
thus significantly reducing the number of structural index modifications.
By reducing the number of structural index updates, we also decrease the likelihood
of conflicting index updates by concurrent transactions.

% By not removing these volatile nodes, we increase performance since we:
% \begin{itemize}
%     \item Reduce the number of structural index modifications, which are expensive because they implicitly cause a sequence of nodes to be added or removed from the index.
%     \item By reducing index modifications, we also decrease the number of index conflicts, which limit throughput since they cause a transaction to abort and restart.
% \end{itemize}

The goal of this project is to implement a WAPI, as proposed by \cite{KW17} in Apache Jackrabbit Oak in order to improve the transactional throughput of Jackrabbit Oak.

\section{System Architecture}

Apache Jackrabbit Oak\footnote{https://jackrabbit.apache.org/oak/} (Oak) is a hierarchical distributed database system which makes use of a hierarchical index. 
Multiple transactions can work concurrently by making use of Multiversion Concurrency Control (MVCC)~\cite{GW02}, a commonly used optimistic technique~\cite{TM11}.

\Cref{fig:architecture} depicts Oak's multi-tier architecture.
Oak embodies the \textit{Database Tier}.
Whilst Oak is responsible for handling the database logic, it stores the actual data on MongoDB\footnote{https://www.mongodb.com/what-is-mongodb}, labeled as \textit{Persistance Tier}.
On the other end, applications can make use of Oak as shown in \cref{fig:architecture} under \textit{Application Tier}.
One such application is Adobe's enterprise content management system (CMS), the Adobe Experience Manager\footnote{http://www.adobe.com/marketing-cloud/experience-manager.html}.

\begin{figure}[h]
    \begin{center}
        \begin{tikzpicture}
            \node (mongo) at (0, 0) {\includegraphics[width = 1cm]{MONGO}};
            \node (oak_a) at (-3, -2) {\includegraphics[width = 1cm]{OAK}};
            \node (oak_b) at (-3, 0) {\includegraphics[width = 1cm]{OAK}};
            \node (oak_c) at (-3, 2) {\includegraphics[width = 1cm]{OAK}};
            \node (app_a) at (-6, -2) {\includegraphics[width = 1cm]{AEM}};
            \node (app_b) at (-6, 0) {\includegraphics[width = 1cm]{AEM}};
            \node (app_c) at (-6, 2) {\includegraphics[width = 1cm]{AEM}};
            \node (mongo_desc) at (0, -3) {\footnotesize Persistance Tier};
            \node (oak_desc) at (-3, -3) {\footnotesize Database Tier};
            \node (mongo_desc) at (-6, -3) {\footnotesize Application Tier};
            \foreach \from/\to in {app_a/oak_a, app_b/oak_b, app_c/oak_c, oak_a/mongo, oak_b/mongo, oak_c/mongo}
            \draw [->] (\from) -- (\to);
        \end{tikzpicture}
    \end{center}
    \caption{Apache Jackrabbit Oak's system architecture.}
    \label{fig:architecture}
\end{figure}

\chapter{Workload Aware Property Index}

The general idea behind the WAPI is to take into account if an index node is volatile before performing structural index modifications.
If a node is considered volatile, we prevent removing it from the index.

In the following chapter, we will see how to add, query and remove nodes from the index.

\section{Insertion}

The WAPI is hierarchically organized under \texttt{/index} node.
The second index level consists of all properties $k$ we want to index.
The third index level contains any values $v$ of $k$.
The remaining index levels replicate all nodes from the root node to any content node with $k$ set to $v$.
Node $m$ is added to the WAPI iff $m$ has a property $k$ set to $v$.

The WAPI is updated as described in \cref{algo:add_triple_wapi}.
Starting from /index, we descent down to /index/k, /index/k/v.
Next, we descent down from /index/k/v with a replica from content node $m$'s absolute path from root.
While we descent the WAPI, we create any node $n$ that does not exist.
Finally, we set $n$'s property $k$ to $v$.

\begin{example}
    Let's consider \cref{fig:add_wapi}.
    Given snapshot $G^i$, transaction $T_j$ adds the property $x=1$ to \texttt{/a/b} and commits snapshot $G^j$.
    Starting from \texttt{/index} and descending down to \texttt{/index/x/1/a/b}, we create each node on the way since they do not exist yet.
    Finally, we set property $x=1$ on \texttt{/index/x/1/a/b}.
\end{example}

\begin{figure}[h]
    \vspace{-5mm}
        \begin{multicols}{2}
            \noindent
            \begin{large}$$ G^i \xrightarrow{\quad T_j \quad} G^j $$\end{large}
            \begin{scriptsize}
                \begin{multicols}{2}
                    \noindent
                    \begin{center}
                        \framebox(100,130){
                            \begin{forest} qtree,
                                [
                                    [$\lambda:\texttt{index}$]
                                    [,phantom]
                                    [$\lambda:a$,name=a
                                        [,phantom]
                                        [$\lambda:b$,name=b]
                                        [,phantom]
                                        [$\lambda:c$]
                                    ]
                                ]
                            \end{forest}
        
                            \vspace{27mm}
                        }
        
                        Snapshot $G^i$
                    \end{center}
                    \columnbreak
                    \begin{center}
                        \framebox(100,130){
                            \begin{forest} qtree,
                                [
                                    [$\lambda:\texttt{index}$
                                        [$\lambda:\texttt{x}$
                                            [$\lambda:\texttt{1}$
                                                [$\lambda:a$
                                                [$\lambda:b$ \\ $\texttt{x}:1$]
                                                ]
                                            ]
                                        ]
                                    ]
                                    [,phantom]
                                    [$\lambda:a$,name=a
                                        [,phantom]
                                        [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$,name=b]
                                        [,phantom]
                                        [$\lambda:c$]
                                    ]
                                ]
                            \end{forest}
                        }
        
                        Snapshot $G^j$
                    \end{center}    
                \end{multicols}
            \end{scriptsize}
            \columnbreak
            ~

            \vspace{7.8mm}
            \begin{algorithm}[H]
                \label{algo:add_triple_wapi}
                \caption{AddTripleWAPI}
                \DontPrintSemicolon
                \begin{footnotesize}
                    \KwData{Triple $(k, v, m)$, where $k$ is a property, $v$ a value and $m$ a content node.}
                    \vspace{2.6mm}
                    \For{$n \in \langle/i/k,~/i/k/v,~\dots,~/i/k/v/m\rangle$}{
                        \If{$n$ does not exist}{
                            create node $n$\;
                        }
                    }
                    $n[k] \longleftarrow v$
                \end{footnotesize}
            \end{algorithm}
            \begin{scriptsize}
                Where $/i$ is an abbreviation for /index.
            \end{scriptsize}
        \end{multicols}
    \vspace{-8mm}
    \caption{Adding a node in a workload aware property index.}
    \label{fig:add_wapi}
\end{figure}

\newpage

\section{Querying}

Oak mostly executes content-and-structure (CAS) queries~\cite{CM15}.

\begin{definition}
    (CAS-Query): Given node $m$, property $k$ and value $v$, a CAS query returns all descendants of $m$ which have $k$ set to the $v$, 
    i.e $$ Q(k,v,m) = \{~n~|~n[k] = v \land n \in desc(m)~\}$$.
\end{definition}

\Cref{algo:query_wapi} describes how we answer the query using the WAPI.
Given property $k$, value $v$ and node $m$, we start descending down to node \texttt{/index/k/v/m}.
Next, we iterate through all descendants $n$ of node $m$.
We return a set consisting of content nodes $*n$ corresponding to every $n$ with property $k$ set to $v$.
If \texttt{/index/k/v/m} does not exist, then $desc(\texttt{/index/k/v/m}) = \emptyset$.

\begin{example}
    Let's consider query $Q(x, 1, /a)$, that is every descendant of \texttt{/a} with \texttt{x} set to $1$.
    Assuming we execute the query on the tree depicted in \cref{fig:cas_query},
    we receive a set including node /a/b, i.e $Q(x, 1, /a) = \{~/a/b~\}$
\end{example}

\begin{figure}[h]
    \begin{multicols}{2}
        \begin{center}
            \
            
            \begin{footnotesize}
                \begin{forest} qtree,
                    [
                        [$\lambda:\texttt{index}$
                            [$\lambda:\texttt{x}$
                                [$\lambda:\texttt{1}$
                                    [$\lambda:a$
                                    [$\lambda:b$ \\ $\texttt{x}:1$]
                                    ]
                                ]
                            ]
                        ]
                        [,phantom]
                        [$\lambda:a$,name=a
                            [,phantom]
                            [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$,name=b]
                            [,phantom]
                            [$\lambda:c$]
                        ]
                    ]
                \end{forest}
            \end{footnotesize}
        \end{center}    
        \columnbreak
        \begin{algorithm}[H]
            \DontPrintSemicolon
            \begin{footnotesize}
                \label{algo:query_wapi}
                \caption{QueryWAPI}
                \KwData{Query $Q(k, v, m)$, where $k$ is a property, $v$ a value and $m$ a node.}
                \KwResult{A set of nodes satisfying $Q(k,v,m)$}
                $r \longleftarrow \emptyset$\;
                \For{$n \in desc(\texttt{/index/k/v/m})$}{
                    \If{$n[k] = v$}{
                        $r \longleftarrow r \cup \{ *n \}$\;
                    }
                }
                \Return{r}\;
            \end{footnotesize}
        \end{algorithm}
        \begin{scriptsize}
            Where $desc(\texttt{/index/k/v/m})$ is the set of descendants of node \texttt{/index/k/v/m}, $n[k]$ is property $k$ of node $n$ and $*n$ is the content node corresponding to $n$.
        \end{scriptsize}
    \end{multicols}
    \caption{CAS Query example.}
    \label{fig:cas_query}
\end{figure}

\section{Deletion}

During deletion, we intend to remove a node from the WAPI.
Volatile nodes influence the logic of the deletion process.
A workload aware property index detects which nodes are volatile and does not remove them.
The process of classifying a node as volatile, will be explained in more details in \Cref{ch:volatility}.
For the moment we assume that a function $isVolatile(n)$ is given that classifies $n$ either as volatile or as non-volatile.

\Cref{algo:remove_triple_wapi} describes the process of removing a node from the workload aware property index.
We first propagate down to node $m$, which we intend to remove.
We remove property $k$ from $m$.
If $m$ is a leaf node and does not have property $k$ and is not volatile, we remove it.
If $m$ was removed, we repeat the process on its parent node.
The process ends if we propagate up to \texttt{/index} or have a node with children or a volatile node or a node that has property $k$.

\begin{example}
    \Cref{fig:remove_wapi} depicts the following scenario.
    Assume \texttt{/index/x/1/a/b} (colored red) is volatile in all three snapshots $G^i, G^j, G^k$.
    Given snapshot $G^i$, transaction $T_j$ removes property $x=1$ from \texttt{/a/b} and commits snapshot $G^j$.
    Since \texttt{/index/x/1/a/b} is volatile, it was not removed from the WAPI.
    Given snapshot $G^j$, transaction $T_k$ removes property \texttt{x} from \texttt{/a/c} and commits snapshot $G^k$.
    Since \texttt{/index/x/1/a/b} is not volatile, it was removed from the WAPI.
\end{example}

\begin{figure}[h]
    \begin{large}
        $$ G^i \xrightarrow{\quad T_j \quad} G^j \xrightarrow{\quad T_k \quad} G^k $$
    \end{large}
    \begin{scriptsize}
        \begin{multicols}{3}
            \begin{center}
                \framebox(130,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                            [$\lambda:b$ \\ $\texttt{x}:1$, red]
                                            [,phantom]
                                            [,phantom]
                                            [$\lambda:c$ \\ $\texttt{x}:1$]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [,phantom]
                            [,phantom]
                            [$\lambda:a$
                                [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$]
                                [,phantom]
                                [$\lambda:c$ \\ $\texttt{x}:\texttt{1}$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^i$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(130,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                            [$\lambda:b$, red]
                                            [,phantom]
                                            [,phantom]
                                            [$\lambda:c$ \\ $\texttt{x}:1$]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [,phantom]
                            [,phantom]
                            [$\lambda:a$
                                [$\lambda:b$]
                                [,phantom]
                                [$\lambda:c$ \\ $\texttt{x}:\texttt{1}$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^j$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(130,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                            [$\lambda:b$, red]
                                                [,phantom]
                                                [,phantom]
                                                [,phantom]
                                                [,phantom]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [,phantom]
                            [,phantom]
                            [$\lambda:a$
                                [$\lambda:b$]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^k$
            \end{center}
        \end{multicols}
    \end{scriptsize}
    \caption{Removing a node from the WAPI. Assume \texttt{/index/x/1/a/b} (colored red) is volatile in all three snapshots $G^i, G^j, G^k$.}
    \label{fig:remove_wapi}
\end{figure}

\begin{algorithm}[H]
    \label{algo:remove_triple_wapi}
    \caption{RemoveTripleWAPI}
    \DontPrintSemicolon
    \begin{footnotesize}
        \KwData{Triple $(k, v, m)$, where $k$ is a property, $v$ a value and $m$ a node.}
        $n \longleftarrow \texttt{/index/k/v/m}$\;
        $n[k] \longleftarrow \textsc{nil}$\;
        \While{$n \neq \texttt{/index} \land chd(n) = \emptyset \land n[k] \neq v \land \lnot \ isVolatile(n)$}{
            $u \longleftarrow n$\;
            $n \longleftarrow par(n)$\;
            remove node $u$\;
        }
    \end{footnotesize}
\end{algorithm}

\chapter{Volatility}
\label{ch:volatility}

Volatility is the measure which is used by the WAPI in order to distinguish when to remove a node or not from the index.

Wellenzohn et al.~\cite{KW17} propose to look at the recent transactional
workload to check whether a node $n$ is volatile. The workload on Oak instance
$O_i$ is represented by a sequence $H_i = \langle \ldots, G^a, G^b, G^c
\rangle$ of snapshots, called a history.  $t_n$ is the current time.  $t(G^b)$
is the point in time snapshot $G^b$ was committed, $N(G^a)$ is the set of
nodes which are members of snapshot $G^a$.  $pre(G^b)$ is the predecessor of
snapshot $G^b$.

Node $n$ is volatile iff $n$'s volatility count is at least $\tau$, called volatility threshold.
The volatility count of $n$ is defined as the number of times $n$ was added or removed from snapshots in history $H_i$ over a sliding window of length $L$.

\begin{definition}
    (Volatility Count): The number of times node $n$ was added or removed from snapshots contained in a sliding window with length $L$ over history $H_i$.
    \begin{equation}
        \begin{split}
            vol(n) = | \{ G^b | G^b \in H_i \land t(G^b) \in [t_{n-L+1}, t_n] \land \exists G^a[ \\
            \qquad G^a = pre(G^b) \land ([n^a \notin N(G^a) \land n^b \in N(G^b)]\lor \\
            \qquad [n^a \in N(G^a) \land n^b \notin N(G^b)] )]\} |
        \end{split}
    \end{equation}
    \label{def:vol_count}
\end{definition}

\begin{definition}
    (Volatile Node): Node $n$ is volatile iff $n$'s volatility count (\Cref{def:vol_count}) is greater or equal than the volatility threshold $\tau$, i.e 
    $$ isVolatile(n) \iff vol(n) \geq \tau $$
\end{definition}

\begin{example}
    Let's consider the snapshots depicted in \cref{fig:vol_example}.
    Assume $\langle G^i,G^j,G^k,G^l \rangle$ is a partition of history $H_h$ on Oak instance $O_h$.
    $O_h$ executes transactions $T_j, T_k, T_l$. Snapshot $G^i$ was committed during $t(G^i) = t$.
    Given snapshot $G^i$, transaction $T_j$ removes property $x$ from \texttt{/a/b} and commits snapshot $G^j$ during $t(G^j) = t + 1$.
    Next, transaction $T_k$ adds the property $x=1$ to \texttt{/a/b} given snapshot $G^j$ and commits snapshot $G^k$ during $t(G^k) = t + 2$.
    Finally transaction $T_l$ removes property \texttt{x} from \texttt{/a/b} given $G^k$ and commits $G^l$ during $t(G^l) = t + 3$.
    
    If $\tau = 2$ (volatility threshold), $L = 4$ (sliding window length) and $n = \texttt{\footnotesize /index/x/1/a/b}$, then:
    \begin{itemize}
        \item at time $t_n = t$ \quad \ \ we have that: \quad $vol(n) = 0 \implies isVolatile(n) = \bot$
        \item at time $t_n = t + 1 $ we have that: \quad $ vol(n) = 1  \implies isVolatile(n) = \bot$
        \item at time $t_n = t + 2 $ we have that: \quad $ vol(n) = 2  \implies isVolatile(n) = \top$
        \item at time $t_n = t + 3 $ we have that: \quad $ vol(n) = 3  \implies isVolatile(n) = \top$
    \end{itemize}    
\end{example}

\begin{figure}[h]
    \begin{large}
        $$ G^i \xrightarrow{\quad T_j \quad} G^j \xrightarrow{\quad T_k \quad} G^k \xrightarrow{\quad T_l \quad} G^l$$
    \end{large}
    \begin{scriptsize}
        \begin{multicols}{4}
            \begin{center}
                \framebox(100,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                        [$\lambda:b$ \\ $\texttt{x}:1$]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$,name=b]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^i$

                $t(G^i) = t$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(100,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$,name=b]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}

                    \vspace{27mm}
                }

                Snapshot $G^j$

                $t(G^j) = t + 1$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(100,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                        [$\lambda:b$ \\ $\texttt{x}:1$, red]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^k$

                $t(G^k) = t + 2$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(100,130){
                    \
                    
                    \vspace{-24mm}
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                           [$\lambda:b$, red]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$,name=b]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}

                    \vspace{27mm}
                }

                Snapshot $G^l$

                $t(G^l) = t + 3$
            \end{center}
        \end{multicols}
    \end{scriptsize}
    \caption{Volatility count changes with each snapshot.}
    \label{fig:vol_example}
\end{figure}

\chapter{Implementation}

\section{Checking Node Volatility}

In order to classify node $n$ as volatile, we have to compute $n$'s volatility count using the corresponding JSON\footnote{http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf} document on MongoDB.
The document contains all revisions of $n$ throughout history $H_i$ of an Oak instance $O_i$.
\Cref{fig:json_simple} depicts such a document.
We omitted non relevant properties.
Property \texttt{"\_deleted"} contains key value pairs which encode when the node was added or removed from snapshots, called revisions.
Each value's key is composed with a timestamp, a counter that is used to differentiate between value changes during the same instance of time and the identifier of the oak instance committing the change.
\begin{example}
    Let's consider \texttt{r15cac0dbb00-0-2} in \cref{fig:json_simple}.
    \texttt{r} is a standard prefix and can be neglected.
    The \texttt{15cac0dbb00} following \texttt{r}, is a timestamp (number of milliseconds since the Epoch) in hexadecimal encoding which represents the time during which the change was committed.
    The \texttt{0} following the timestamp, is a counter which is used for tie-breaking between transactions committed during the same instance of time.
    The \texttt{2} following the counter, tells that the change was committed by the Oak instance with an id of \texttt{2}.
\end{example}

\begin{figure}[h]
    \begin{scriptsize}
        \begin{centerverbatim}{   
    "_id": "5:/index/x/1/a/b", 
    "_deleted": {             
        "r15cac0dbb00-0-2": false,
        "r15cabff1500-0-2": true,
        "r15ca9f191c0-0-1": false,
        /* ... */
    },
    /* ... */
}\end{centerverbatim}
    \end{scriptsize}
    \caption{JSON document of an index node.}
    \label{fig:json_simple}
\end{figure}

Having seen what a node document looks like, we can now describe how we classify a node as volatile.
\Cref{fig:is_volatile} shows the native implementation of $isVolatile(n)$ in Java.
\begin{example}
    As shown in \cref{fig:is_volatile}, $isVolatile(n)$ is given a node's corresponding document.
    We iterate through the revisions of property \texttt{"\_deleted"} in most-recent first fashion.
    If a revision is outside the sliding window we stop iterating because remaining revisions cannot be more recent.
    We increment the volatility count for every visible revision.
    A revision is visible if it is contained in the Oak instance's history.
    If the volatility count reaches at least $\tau$ we break the loop.
    When exiting the loop, we finally check if the volatility count is at least $\tau$ and return the result.
\end{example}

\begin{figure}[h]
    \begin{framed}
        \begin{scriptsize}
            \begin{minted}{java}
/**
 * Determines if node is volatile.
 * @param nodeDocument: document of node.
 * @returns true iff node is volatile.
 */            
 boolean isVolatile(NodeDocument nodeDocument) {

    int vol = 0;
    
    for (Revision r : nodeDocument.getLocalDeleted().keySet()) {
        if (!isInSlidingWindow(r)){
            break;
        }
        if (!isVisible(r)){
            continue;
        }
        if (++vol >= getVolatilityThreshold()) {
            break;
        }
    }
    return vol >= getVolatilityThreshold();
}
            \end{minted}
        \end{scriptsize}
    \end{framed}
    \caption{Java implementation for detecting volatile index nodes.}
    \label{fig:is_volatile}
\end{figure}

\begin{figure}[h]
    \begin{framed}
        \begin{scriptsize}
            \begin{minted}{java}
/**
 * Checks if r is visible to the local cluster node
 * @param r the revision
 * @returns true iff r is visible to the local cluster node
 */
boolean isVisible(Revision r) {
    return r.getClusterId() == getClusterId()
            || (r.compareRevisionTime(documentNodeStore
                    .getHeadRevision()
                    .getRevision(getClusterId())) < 0);
}

/**
 * Checks if r is in the sliding window
 * @param r the revision
 * @returns true iff r is in the sliding window
 */
boolean isInSlidingWindow(Revision r){
    return System.currentTimeMillis() - getSlidingWindowLength() < r.getTimestamp();
}
            \end{minted}
        \end{scriptsize}
    \end{framed}
    \caption{Java implementation for helper functions.}
    \label{algo:helper_functions}
\end{figure}

\section{Document Splitting}

\begin{figure}[h]
    \begin{framed}
        \begin{scriptsize}
            \begin{minted}{java}
/**
* Collects all local property changes committed by the current
* cluster node.
* @param committedLocally local changes committed by the current cluster node.
* @param changes all revisions of local changes (committed and uncommitted).
*/
void collectLocalChanges(
        Map<String, NavigableMap<Revision, String>> committedLocally,
        Set<Revision> changes) {

    int vol = 0;
    
    // for each public property or "_deleted"
    for (String property : filter(doc.keySet(), PROPERTY_OR_DELETED)) {
        NavigableMap<Revision, String> splitMap =
                new TreeMap<Revision, String>(StableRevisionComparator.INSTANCE);
        committedLocally.put(property, splitMap);

        // local property revisions
        Map<Revision, String> valueMap = doc.getLocalMap(property);
        
        // for each Revision & Value tuple in 
        for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {
            Revision r = entry.getKey();

            if (property.equals("_deleted")) {
                if (!isVisible(r)){
                    continue;
                }
                if (isInSlidingWindow(r) && vol++ < getVolatilityThreshold()){
                    continue;
                }
            }
            if (r.getClusterId() != context.getClusterId()) {
                continue;
            }

            // move to split document
            changes.add(r);
            if (isCommitted(context.getCommitValue(r, doc))) {
                splitMap.put(r, entry.getValue());
            } else if (isGarbage(r)) {
                addGarbage(r, property);
            }
        }
    }
}
            \end{minted}
        \end{scriptsize}
    \end{framed}
    \caption{Java implementation for splitting the node document.}
    \label{algo:split_document}
\end{figure}

\begin{figure}[h]
    \begin{algorithm}[H]
        \DontPrintSemicolon
        \begin{footnotesize}
            \label{algo:split_document_wapi}
            \caption{SplitDocumentWAPI}
            \KwData{Document $d$.}
            $vol \longleftarrow 0$\;
            \ForEach{versioned property $k \in d$}{
                \ForEach{revision $r \in d[k]$}{
                    \If{$k = \texttt{\_deleted}$}{
                        \If{$c(r) \neq O_i \land t_{\texttt{last\_sync}} < t(r)$}{\textbf{continue}\;}
                        \If{$t(r) \in [t_{n-L+1},t_n]$}{
                            $vol \longleftarrow vol + 1$\;
                            \If{$vol \leq \tau$}{\textbf{continue}\;}
                        }
                    }
                    \If{$c(r) \neq O_i$}{\textbf{continue}\;}
                    \texttt{moveToSplitDocument($d$, $k$, $r$)}\;
                }
            }
        \end{footnotesize}
    \end{algorithm}
    Where $\tau$ is the volatility threshold, 
    $L$ the sliding window length, 
    $O_i$ the local cluster node, 
    $t_n$ the current time, 
    $c(r)$ the cluster node which committed revision $r$ and 
    $t(r)$ the point of time revision $r$ was committed.
\end{figure}

\begin{figure}[h]
    
\end{figure}

\begin{figure}
    \begin{multicols}{2}
        \begin{scriptsize}
            \begin{center}
                \begin{verbatim}
{   
  "_id": "5:/index/x/1/a/b", 
  "_deleted": {                 /* DD HH:MM */
    "r15cac0dbb00-0-2": false,  /* 15 14:00 */
    "r15cabff1500-0-2": true,   /* 15 13:44 */
    "r15ca9f191c0-0-1": false,  /* 15 04:10 */
    "r15ca76fc8e0-0-1": true,   /* 14 16:29 */
    "r15ca73b9980-0-1": false,  /* 14 15:32 */
    "r15ca5e9c520-0-2": true,   /* 14 09:23 */
    "r15ca5a8c480-0-1": false,  /* 14 08:12 */
    "r15ca5a6efc0-0-1": true,   /* 14 08:10 */
    "r15ca58e37a0-0-1": false,  /* 14 07:43 */
  },
  /* ... */
}\end{verbatim}
            \end{center}
        \end{scriptsize}
        \columnbreak
        
        \begin{center}
            \begin{footnotesize}
                \begin{tabular}{|c|c|c|c|c|c|} 
                    \hline
                    $t(r)$ &    $c(r)$ &        Vis. &      $\in$Win. &         Vol. &      Split \\
                    \hline
                    15 14:00 &  2 &             $\bot$ &         $\top$ &                 0 &                 $\bot$ \\ 
                    \hline
                    15 13:44 &  2 &             $\top$ &         $\top$ &                 1 &                 $\bot$ \\
                    \hline
                    15 04:10 &  1 &             $\top$ &         $\top$ &                 2 &                 $\bot$ \\
                    \hline
                    14 16:29 &  1 &             $\top$ &         $\top$ &                 3 &                 $\bot$ \\
                    \hline
                    14 15:32 &  1 &             $\top$ &         $\top$ &                 4 &                 $\top$ \\
                    \hline
                    14 09:23 &  2 &             $\top$ &         $\bot$ &                 4 &                 $\bot$ \\
                    \hline
                    14 08:12 &  1 &             $\top$ &         $\bot$ &                 4 &                 $\top$ \\
                    \hline
                    14 08:10 &  1 &             $\top$ &         $\bot$ &                 4 &                 $\top$ \\
                    \hline
                    14 07:43 &  1 &             $\top$ &         $\bot$ &                 4 &                 $\top$ \\
                    \hline
                \end{tabular}
            \end{footnotesize}
        \end{center}
    \end{multicols}
    Intermediate values of computation while splitting document a.

    Assume $\tau = 3$, $O_i = 1$, $t_{\texttt{last\_sync}} = $ {\footnotesize 2017.06.15 13:59}, $L = 24$ hours, $t_n = $ {\footnotesize 2017.06.15 14:01}.
    \begin{itemize}
        \item "$t(r)$" is the point of time revision $r$ was committed. Only the day, hours and minutes are showed for brevity.
        \item "$c(r)$" is the cluster node which committed revision $r$.
        \item "Vis." is true iff the revision is \textbf{visible} to the local cluster node.
        \item "$\in$Win." is true iff the revision is \textbf{in the sliding window}.
        \item "Vol." represents the \textbf{volatility} count during that step of the iteration. 
        \item "Split" is true iff the revision is moved to the split document.
    \end{itemize}
\end{figure}

\bibliographystyle{abbrv}
\bibliography{vertiefung}

\end{document}
