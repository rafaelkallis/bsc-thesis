\documentclass[abstracton,12pt]{scrreprt}

\usepackage[utf8]{inputenc}
% \usepackage[T1]{fontenc}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tikz}
\usepackage{listings}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{amsmath}
\usepackage{pdfpages}
\usepackage{forest}
\usepackage{multicol}
\usepackage{varwidth}
\usepackage{verbatim}
\usepackage{cleveref}
\usepackage{minted}
\usepackage{framed}
\usepackage[ruled,vlined]{algorithm2e}

\forestset{qtree/.style={for tree={parent anchor=south, child anchor=north,align=left,inner sep=0pt}}}
\graphicspath{ {images/} }
% --------- 

\titlehead{Department of Informatics, University of Zürich}
\subject{\vspace*{2cm}BSc Vertiefungsarbeit}
\title{Detecting Volatile Index Nodes in a Hierarchical Database System}
\author{
  Rafael Kallis\\[-5pt]
  \scriptsize Matrikelnummer: 14-708-887\\[-5pt]
  \scriptsize Email: \texttt{rk@rafaelkallis.com}
}
\date{\vspace*{2cm}October 3, 2017}
\publishers{
  \small supervised by Prof.\ Dr.\ Michael\ Böhlen and Kevin\ Wellenzohn \\[5cm]
  \begin{tikzpicture}[overlay]
    \node at (-3,-3) {\includegraphics[height=1.5cm]{IFIlogo}};
    \node at (7,-3) {\includegraphics[height=1.5cm]{dbtgBW}};
  \end{tikzpicture}
}

% \dedication{dedicated to xxx}

% --------- 

\newtheorem{definition}{Definition}
% \newtheorem{figure}{Figure}
% \newtheorem{example}{Example}
% \newtheorem{theorem}{Theorem}
% \newtheorem{lemma}{Lemma}

\crefname{algocfline}{algorithm}{algorithms}
\Crefname{algocfline}{Algorithm}{Algorithms}


% \newenvironment{proof}
%     {\noindent{\bf Proof:\rm}}{\hfill$\Box$\vspace{\medskipamount}}

\newenvironment{centerverbatim}{\par\centering\varwidth{\linewidth}\verbatim}
    {\endverbatim\endvarwidth\par}

\def\bbbr{{\rm I\!R}}
\def\bbbm{{\rm I\!M}}
\def\bbbn{{\rm I\!N}}
\def\bbbz{{\rm I\!Z}}

% --------- 

\begin{document}

\maketitle

% \chapter*{Acknowledgements}

% \begin{abstract}
%   ...
% \end{abstract}

% \chapter*{Zusammenfassung}

% \tableofcontents
% \listoffigures
% \listoftables

\chapter{INTRODUCTION}

Hierarchical indexes with skewed and update-heavy workloads grow and shrink often,
since adding and removing nodes cause a sequence of nodes to be added or removed in addition, thus deteriorating the index update performance.
Index update performance also suffers from conflicting index updates.
Highly skewed workloads create hotspots where nodes are frequently added or removed, increasing conflicting index updates, as shown in (ref kevin paper).
A frequently added or removed node is a volatile node.

Wellenzohn et al. (ref) propose a workload aware property index (WAPI). 
The WAPI exploits the workloads' skewness by not removing volatile nodes from the index.
By not removing these volatile nodes, we increase performance since we:
\begin{itemize}
    \item Reduce the amount of index modifications, which are expensive because they implicitly cause a sequence of nodes to be added or removed from the index.
    \item By reducing index modifications, we also decrease the number of index conflicts, which limit throughput since they cause a transaction to abort and restart.
\end{itemize}

The goal of this project is to implement a WAPI, as proposed by (ref kevin paper) in Apache Jackrabbit Oak in order to improve throughput.

\chapter{PRELIMINARIES}

\section{System Architecture}

Apache Jackrabbit Oak (reference) (Oak) is a hierarchical distributed database system which makes use of a hierarchical index. 
Multiple transactions can work concurrently by making use of Multiversion Concurrency Control (MVCC) (reference), a commonly used optimistic technique (reference Principals of Distributed databases).
Whilst Oak is responsible for handling the database logic, it stores the actual data on MongoDB.
Although Oak is an open-source project, it is being actively maintained by Adobe (reference).
Adobe's content management system (CMS) makes use of Oak in one of their products, specifically Adobe Experience Manager.

\begin{figure}[h]
    \begin{center}
        \begin{tikzpicture}
            \node (mongo) at (0, 0) {\includegraphics[width = 1cm]{MONGO}};
            \node (oak_a) at (-3, -2) {\includegraphics[width = 1cm]{OAK}};
            \node (oak_b) at (-3, 0) {\includegraphics[width = 1cm]{OAK}};
            \node (oak_c) at (-3, 2) {\includegraphics[width = 1cm]{OAK}};
            \node (app_a) at (-6, -2) {\includegraphics[width = 1cm]{AEM}};
            \node (app_b) at (-6, 0) {\includegraphics[width = 1cm]{AEM}};
            \node (app_c) at (-6, 2) {\includegraphics[width = 1cm]{AEM}};
            \node (mongo_desc) at (0, -3) {\footnotesize Persistance Tier};
            \node (oak_desc) at (-3, -3) {\footnotesize Database Tier};
            \node (mongo_desc) at (-6, -3) {\footnotesize Application Tier};
            \foreach \from/\to in {app_a/oak_a, app_b/oak_b, app_c/oak_c, oak_a/mongo, oak_b/mongo, oak_c/mongo}
            \draw [->] (\from) -- (\to);
        \end{tikzpicture}
    \end{center}
    \caption{Apache Jackrabbit Oak's system architecture.}
\end{figure}

\section{Notation}

\chapter{WAPI}

The WAPI is hierarchically organized under \texttt{/index} node.
The second index level consists of all properties $k$ we want to index.
The third index level contains any values $v$ of $k$.
The remaining index levels replicate all nodes from the root node to any content node with $k$ set to $v$.
In the following chapter, we will see how to add, query and remove nodes from the index.

\section{Insertion}

Node $n$ is added to the WAPI iff $n$ has a property $k$ set to $v$.
Let's consider \cref{fig:add_wapi}.
Given snapshot $G^i$, transaction $T_j$ adds the property-value pair \texttt{x:1} to \texttt{/a/b} and commits snapshot $G^j$.
The WAPI is updated as described in \cref{algo:add_triple_wapi}.

\begin{figure}[h]
        \begin{multicols}{2}
            \begin{large}
                $$ G^i \xrightarrow{\quad T_j \quad} G^j $$
            \end{large}
            \begin{scriptsize}
                \begin{multicols}{2}
                    \begin{center}
                        \framebox(100,130){
                            \begin{forest} qtree,
                                [
                                    [$\lambda:\texttt{index}$]
                                    [,phantom]
                                    [$\lambda:a$,name=a
                                        [,phantom]
                                        [$\lambda:b$,name=b]
                                        [,phantom]
                                        [$\lambda:c$]
                                    ]
                                ]
                            \end{forest}
        
                            \vspace{27mm}
                        }
        
                        Snapshot $G^i$
                    \end{center}
                    \columnbreak
                    \begin{center}
                        \framebox(100,130){
                            \begin{forest} qtree,
                                [
                                    [$\lambda:\texttt{index}$
                                        [$\lambda:\texttt{x}$
                                            [$\lambda:\texttt{1}$
                                                [$\lambda:a$
                                                [$\lambda:b$ \\ $\texttt{x}:1$]
                                                ]
                                            ]
                                        ]
                                    ]
                                    [,phantom]
                                    [$\lambda:a$,name=a
                                        [,phantom]
                                        [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$,name=b]
                                        [,phantom]
                                        [$\lambda:c$]
                                    ]
                                ]
                            \end{forest}
                        }
        
                        Snapshot $G^j$
                    \end{center}    
                \end{multicols}
            \end{scriptsize}
            \columnbreak
            \ 

            \vspace{12.2mm}
            \begin{algorithm}[H]
                \label{algo:add_triple_wapi}
                \caption{AddTripleWAPI}
                \DontPrintSemicolon
                \begin{footnotesize}
                    \KwData{Triple $(k, v, m)$, where $k$ is a property, $v$ a value and $m$ a node.}
                    \vspace{2.6mm}
                    $n \longleftarrow \texttt{/index}$\;
                    \For{$\lambda \in \langle\, k,\, v,\, \dots\,,\, par(m)[\lambda],\, m[\lambda] \, \rangle$}{
                        $n \longleftarrow n | \lambda$\;
                        \If{$n$ does not exist}{
                            create node $n$\;
                        }
                    }
                    $n[k] \longleftarrow v$
                \end{footnotesize}
            \end{algorithm}
        \end{multicols}
    \caption{Adding a node in a workload aware property index.}
    \label{fig:add_wapi}
\end{figure}

\section{Querying}

Oak mostly executes content-and-structure (CAS) queries \textbf{(ref)}.
An example of such a query can be found in \cref{fig:cas_query}.

\begin{definition}
    (CAS-Query): Given node $m$, property $k$ and value $v$, a CAS query returns all descendants of $m$ which have $k$ set to the $v$.
    {\large$Q_{k,v,m} = \{ \, n \, | \, n[k] = v \land n \in desc(m) \, \} $}
\end{definition}

\begin{figure}[h]
    \begin{multicols}{2}
        \begin{center}
            \
            
            \begin{footnotesize}
                \begin{forest} qtree,
                    [
                        [$\lambda:\texttt{index}$
                            [$\lambda:\texttt{x}$
                                [$\lambda:\texttt{1}$
                                    [$\lambda:a$
                                    [$\lambda:b$ \\ $\texttt{x}:1$]
                                    ]
                                ]
                            ]
                        ]
                        [,phantom]
                        [$\lambda:a$,name=a
                            [,phantom]
                            [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$,name=b]
                            [,phantom]
                            [$\lambda:c$]
                        ]
                    ]
                \end{forest}
            \end{footnotesize}
        \end{center}    
        \columnbreak
        \begin{algorithm}[H]
            \DontPrintSemicolon
            \begin{scriptsize}
                \label{algo:query_pi}
                \caption{QueryWAPI}
                \KwData{Triple $(k, v, m)$, where $k$ is a property, $v$ a value and $m$ a node.}
                \KwResult{A set of paths satisfying CAS query $Q_{k,v,m}$}
                $n \longleftarrow \texttt{/index}$\;
                \For{$\lambda \in \langle\, k,\, v,\, \dots\,,\, par(m)[\lambda],\, m[\lambda] \, \rangle$}{
                    $n \longleftarrow n | \lambda$\;
                    \If{$n$ does not exist}{
                        \Return{$\emptyset$}\;
                    }
                }
                $r \longleftarrow \emptyset$\;
                \For{$d \in desc(n)$}{
                    \If{$d[k] = v$}{
                        $r \longleftarrow r \cup \{ trunc(d) \}$\;
                    }
                }
                \Return{r}\;
            \end{scriptsize}
        \end{algorithm}
    \end{multicols}
    \begin{footnotesize}
        Having the following query, that is every descendant of \texttt{/a} with \texttt{x} set to $1$,
        we receive a set including node \texttt{/a/b}.
    \end{footnotesize}
    \begin{large}
        $$ Q_{\texttt{x}, 1, \texttt{/a}} = \{\,\texttt{\normalsize/a/b}\,\}$$
    \end{large}
    \caption{CAS Query example.}
    \label{fig:cas_query}
\end{figure}

\section{Deletion}

A workload aware property index differentiates itself mostly when nodes are removed.
It detects which nodes are volatile and avoids removing them.
The process of classifying a node as volatile, will be explained in more details in \Cref{ch:volatility}.
We first propagate down to node $m$, which we intend to remove.
We remove property $k$ from $m$.
If $m$ is a leaf node and does not have property $k$ and is not volatile, we remove it.
If $m$ was removed, we repeat the process on its parent node.
The process ends if we propagate up to \texttt{\index} or have a node with children or a volatile node.

\Cref{fig:remove_wapi} depicts the following scenario.
Assume \texttt{/index/x/1/a/b} (colored red) is volatile in all three snapshots $G^i, G^j, G^k$.
Given snapshot $G^i$, transaction $T_j$ removes property \texttt{x} from \texttt{/a/b} and commits snapshot $G^j$.
Since \texttt{/index/x/1/a/b} is volatile, it is not removed from the WAPI.
Given snapshot $G^j$, transaction $T_k$ removes property \texttt{x} from \texttt{/a/c} and commits snapshot $G^k$.
Since \texttt{/index/x/1/a/b} is not volatile, it is removed from the WAPI.

\Cref{algo:remove_triple_wapi} describes the process of removing a node from the workload aware property index.

\begin{figure}[h]
    \begin{large}
        $$ G^i \xrightarrow{\quad T_j \quad} G^j \xrightarrow{\quad T_k \quad} G^k $$
    \end{large}
    \begin{scriptsize}
        \begin{multicols}{3}
            \begin{center}
                \framebox(130,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                            [$\lambda:b$ \\ $\texttt{x}:1$, red]
                                            [,phantom]
                                            [,phantom]
                                            [$\lambda:c$ \\ $\texttt{x}:1$]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [,phantom]
                            [,phantom]
                            [$\lambda:a$
                                [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$]
                                [,phantom]
                                [$\lambda:c$ \\ $\texttt{x}:\texttt{1}$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^i$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(130,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                            [$\lambda:b$, red]
                                            [,phantom]
                                            [,phantom]
                                            [$\lambda:c$ \\ $\texttt{x}:1$]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [,phantom]
                            [,phantom]
                            [$\lambda:a$
                                [$\lambda:b$]
                                [,phantom]
                                [$\lambda:c$ \\ $\texttt{x}:\texttt{1}$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^j$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(130,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                            [$\lambda:b$, red]
                                                [,phantom]
                                                [,phantom]
                                                [,phantom]
                                                [,phantom]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [,phantom]
                            [,phantom]
                            [$\lambda:a$
                                [$\lambda:b$]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^k$
            \end{center}
        \end{multicols}
    \end{scriptsize}
    \caption{Removing a node from the WAPI. Assume \texttt{/index/x/1/a/b} (colored red) is volatile in all three snapshots $G^i, G^j, G^k$.}
    \label{fig:remove_wapi}
\end{figure}

\begin{algorithm}[H]
    \label{algo:remove_triple_wapi}
    \caption{RemoveTripleWAPI}
    \DontPrintSemicolon
    \begin{footnotesize}
        \KwData{Triple $(k, v, m)$, where $k$ is a property, $v$ a value and $m$ a node.}
        \Begin{
            $n \longleftarrow \texttt{/index/k/v/m}$\;
            $n[k] \longleftarrow \textsc{nil}$\;
            \While{$n \neq \texttt{/index} \land chd(n) = \emptyset \land n[k] \neq v \land \lnot \ isVolatile(n)$}{
                $u \longleftarrow n$\;
                $n \longleftarrow par(n)$\;
                remove node $u$\;
            }
        }
    \end{footnotesize}
\end{algorithm}

\chapter{VOLATILITY}
\label{ch:volatility}

\begin{definition}
    \begin{equation}
        \begin{split}
            vol(n) = | \{ G^b | G^b \in H_i \land t(G^b) \in [t_{n-L+1}, t_n] \land \exists G^a[ \\
            \qquad G^a = pre(G^b) \land ([n^a \notin N(G^a) \land n^b \in N(G^b)]\lor \\
            \qquad [n^a \in N(G^a) \land n^b \notin N(G^b)] )]\} |
        \end{split}
    \end{equation}
    (Volatility Count): The number of times node $n$ was added or removed from snapshots contained in a sliding window with length $L$ over history $H_i$.
    $t_n$ is the current time.
    $t(G^b)$ is the point in time snapshot $G^b$ was committed, $N(G^a)$ is the set of nodes which are members of snapshot $G^a$.
    $pre(G^b)$ is the predecessor of snapshot $G^b$.
    \label{def:vol_count}
\end{definition}

\begin{definition}
    \begin{equation}
            isVolatile(n) \iff vol(n) \geq \tau 
    \end{equation}
    (Volatile Node): Node $n$ is volatile iff $n$'s volatility count (\cref{def:vol_count}) is greater or equal than the volatility threshold $\tau$.
\end{definition}

\begin{figure}[h]
    \begin{large}
        $$ G^i \xrightarrow{\quad T_j \quad} G^j \xrightarrow{\quad T_k \quad} G^k \xrightarrow{\quad T_l \quad} G^l$$
    \end{large}
    \begin{scriptsize}
        \begin{multicols}{4}
            \begin{center}
                \framebox(100,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                        [$\lambda:b$ \\ $\texttt{x}:1$]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$,name=b]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^i$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(100,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$,name=b]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}

                    \vspace{27mm}
                }

                Snapshot $G^j$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(100,130){
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                        [$\lambda:b$ \\ $\texttt{x}:1$, red]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$ \\ $\texttt{x}:\texttt{1}$]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}
                }

                Snapshot $G^k$
            \end{center}
            \columnbreak
            \begin{center}
                \framebox(100,130){
                    \
                    
                    \vspace{-24mm}
                    \begin{forest} qtree,
                        [
                            [$\lambda:\texttt{index}$
                                [$\lambda:\texttt{x}$
                                    [$\lambda:\texttt{1}$
                                        [$\lambda:a$
                                           [$\lambda:b$, red]
                                        ]
                                    ]
                                ]
                            ]
                            [,phantom]
                            [$\lambda:a$,name=a
                                [,phantom]
                                [$\lambda:b$,name=b]
                                [,phantom]
                                [$\lambda:c$]
                            ]
                        ]
                    \end{forest}

                    \vspace{27mm}
                }

                Snapshot $G^l$
            \end{center}
        \end{multicols}
    \end{scriptsize}
    $\langle G^i,G^j,G^k,G^l \rangle$ is a partition of history $H_h$.
    
    Given $G^i$, transaction $T_j$ removes property \texttt{x} from \texttt{/a/b} and commits $G^j$.
    
    Given $G^j$, transaction $T_k$ adds the property-value pair \texttt{x:}$1$ to \texttt{/a/b} and commits $G^k$.
    
    Given $G^k$, transaction $T_l$ removes property \texttt{x} from \texttt{/a/b} and commits $G^l$.

    Assume $t(G^i) = t, \quad t(G^j) = t + 1, \quad t(G^k) = t + 2, \quad t(G^l) = t + 3$.
    If $\tau = 2$ (volatility threshold), $L = 4$ (sliding window length) and $n = \texttt{\footnotesize /index/x/1/a/b}$, then:
    \begin{itemize}
        \item at time $t_n = t$ \quad \ \ we have that: $ vol(n) = 0 \geq \tau\iff isVolatile(n) = \bot$
        \item at time $t_n = t + 1 $ we have that: $ vol(n) = 1 \geq \tau \iff isVolatile(n) = \bot$
        \item at time $t_n = t + 2 $ we have that: $ vol(n) = 2 \geq \tau \iff isVolatile(n) = \top$
        \item at time $t_n = t + 3 $ we have that: $ vol(n) = 3 \geq \tau \iff isVolatile(n) = \top$
    \end{itemize}    
    \caption{Volatility count changes with each snapshot.}
    \label{fig:vol_example}
\end{figure}

\chapter{IMPLEMENTATION}

\section{Checking Node Volatility}

\begin{figure}[h]
    \begin{framed}
        \begin{scriptsize}
            \begin{minted}{java}
/**
 * Determines if node is volatile.
 * @param nodeDocument: document of node.
 * @returns true iff node is volatile.
 */            
 boolean isVolatile(NodeDocument nodeDocument) {

    int vol = 0;
    
    for (Revision r : nodeDocument.getLocalDeleted().keySet()) {
        if (!isInSlidingWindow(r)){
            break;
        }
        if (!isVisible(r)){
            continue;
        }
        if (++vol >= getVolatilityThreshold()) {
            return true;
        }
    }
    return false;
}
            \end{minted}
        \end{scriptsize}
    \end{framed}
    \caption{Java implementation for detecting volatile index nodes.}
    \label{algo:is_volatile}
\end{figure}

\begin{figure}[h]
    \begin{framed}
        \begin{scriptsize}
            \begin{minted}{java}
/**
 * Checks if r is visible to the local cluster node
 * @param r the revision
 * @returns true iff r is visible to the local cluster node
 */
boolean isVisible(Revision r) {
    return r.getClusterId() == getClusterId()
            || (r.compareRevisionTime(documentNodeStore
                    .getHeadRevision()
                    .getRevision(getClusterId())) < 0);
}

/**
 * Checks if r is in the sliding window
 * @param r the revision
 * @returns true iff r is in the sliding window
 */
boolean isInSlidingWindow(Revision r){
    return System.currentTimeMillis() - getSlidingWindowLength() < r.getTimestamp();
}
            \end{minted}
        \end{scriptsize}
    \end{framed}
    \caption{Java implementation for helper functions.}
    \label{algo:helper_functions}
\end{figure}

\section{Document Splitting}

\begin{figure}[h]
    \begin{framed}
        \begin{scriptsize}
            \begin{minted}{java}
/**
* Collects all local property changes committed by the current
* cluster node.
* @param committedLocally local changes committed by the current cluster node.
* @param changes all revisions of local changes (committed and uncommitted).
*/
void collectLocalChanges(
        Map<String, NavigableMap<Revision, String>> committedLocally,
        Set<Revision> changes) {

    int vol = 0;
    
    // for each public property or "_deleted"
    for (String property : filter(doc.keySet(), PROPERTY_OR_DELETED)) {
        NavigableMap<Revision, String> splitMap =
                new TreeMap<Revision, String>(StableRevisionComparator.INSTANCE);
        committedLocally.put(property, splitMap);

        // local property revisions
        Map<Revision, String> valueMap = doc.getLocalMap(property);
        
        // for each Revision & Value tuple in 
        for (Map.Entry<Revision, String> entry : valueMap.entrySet()) {
            Revision r = entry.getKey();

            if (property.equals("_deleted")) {
                if (!isVisible(r)){
                    continue;
                }
                if (isInSlidingWindow(r) && ++vol <= getVolatilityThreshold()){
                    continue;
                }
            }
            if (r.getClusterId() != context.getClusterId()) {
                continue;
            }

            // move to split document
            changes.add(r);
            if (isCommitted(context.getCommitValue(r, doc))) {
                splitMap.put(r, entry.getValue());
            } else if (isGarbage(r)) {
                addGarbage(r, property);
            }
        }
    }
}
            \end{minted}
        \end{scriptsize}
    \end{framed}
    \caption{Java implementation for splitting the node document.}
    \label{algo:split_document}
\end{figure}

\begin{figure}[h]
    \begin{algorithm}[H]
        \DontPrintSemicolon
        \begin{footnotesize}
            \label{algo:split_document_wapi}
            \caption{SplitDocumentWAPI}
            \KwData{Document $d$.}
            $vol \longleftarrow 0$\;
            \ForEach{versioned property $k \in d$}{
                \ForEach{revision $r \in d[k]$}{
                    \If{$k = \texttt{\_deleted}$}{
                        \If{$c(r) \neq O_i \land t_{\texttt{last\_sync}} < t(r)$}{\textbf{continue}\;}
                        \If{$t(r) \in [t_{n-L+1},t_n]$}{
                            $vol \longleftarrow vol + 1$\;
                            \If{$vol \leq \tau$}{\textbf{continue}\;}
                        }
                    }
                    \If{$c(r) \neq O_i$}{\textbf{continue}\;}
                    \texttt{moveToSplitDocument($d$, $k$, $r$)}\;
                }
            }
        \end{footnotesize}
    \end{algorithm}
    Where $\tau$ is the volatility threshold, 
    $L$ the sliding window length, 
    $O_i$ the local cluster node, 
    $t_n$ the current time, 
    $c(r)$ the cluster node which committed revision $r$ and 
    $t(r)$ the point of time revision $r$ was committed.
\end{figure}

\begin{figure}[h]
    
\end{figure}

\begin{figure}
    \begin{multicols}{2}
        \begin{scriptsize}
            \begin{center}
                \begin{verbatim}
{   
  "_id": "5:/index/x/1/a/b", 
  "_deleted": {                 /* DD HH:MM */
    "r15cac0dbb00-0-2": false,  /* 15 14:00 */
    "r15cabff1500-0-2": true,   /* 15 13:44 */
    "r15ca9f191c0-0-1": false,  /* 15 04:10 */
    "r15ca76fc8e0-0-1": true,   /* 14 16:29 */
    "r15ca73b9980-0-1": false,  /* 14 15:32 */
    "r15ca5e9c520-0-2": true,   /* 14 09:23 */
    "r15ca5a8c480-0-1": false,  /* 14 08:12 */
    "r15ca5a6efc0-0-1": true,   /* 14 08:10 */
    "r15ca58e37a0-0-1": false,  /* 14 07:43 */
  },
  /* ... */
}\end{verbatim}
            \end{center}
        \end{scriptsize}
        \columnbreak
        
        \begin{center}
            \begin{footnotesize}
                \begin{tabular}{|c|c|c|c|c|c|} 
                    \hline
                    $t(r)$ &    $c(r)$ &        Vis. &      $\in$Win. &         Vol. &      Split \\
                    \hline
                    15 14:00 &  2 &             $\bot$ &         $\top$ &                 0 &                 $\bot$ \\ 
                    \hline
                    15 13:44 &  2 &             $\top$ &         $\top$ &                 1 &                 $\bot$ \\
                    \hline
                    15 04:10 &  1 &             $\top$ &         $\top$ &                 2 &                 $\bot$ \\
                    \hline
                    14 16:29 &  1 &             $\top$ &         $\top$ &                 3 &                 $\bot$ \\
                    \hline
                    14 15:32 &  1 &             $\top$ &         $\top$ &                 4 &                 $\top$ \\
                    \hline
                    14 09:23 &  2 &             $\top$ &         $\bot$ &                 4 &                 $\bot$ \\
                    \hline
                    14 08:12 &  1 &             $\top$ &         $\bot$ &                 4 &                 $\top$ \\
                    \hline
                    14 08:10 &  1 &             $\top$ &         $\bot$ &                 4 &                 $\top$ \\
                    \hline
                    14 07:43 &  1 &             $\top$ &         $\bot$ &                 4 &                 $\top$ \\
                    \hline
                \end{tabular}
            \end{footnotesize}
        \end{center}
    \end{multicols}
    Intermediate values of computation while splitting document a.

    Assume $\tau = 3$, $O_i = 1$, $t_{\texttt{last\_sync}} = $ {\footnotesize 2017.06.15 13:59}, $L = 24$ hours, $t_n = $ {\footnotesize 2017.06.15 14:01}.
    \begin{itemize}
        \item "$t(r)$" is the point of time revision $r$ was committed. Only the day, hours and minutes are showed for brevity.
        \item "$c(r)$" is the cluster node which committed revision $r$.
        \item "Vis." is true iff the revision is \textbf{visible} to the local cluster node.
        \item "$\in$Win." is true iff the revision is \textbf{in the sliding window}.
        \item "Vol." represents the \textbf{volatility} count during that step of the iteration. 
        \item "Split" is true iff the revision is moved to the split document.
    \end{itemize}
\end{figure}

\end{document}
